<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  
</body>
</html>
<script>
/* 
  力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。
  小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：

  U: 向y轴正方向移动一格
  R: 向x轴正方向移动一格。
  不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。

  给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
  示例 1：

    输入：command = "URR", obstacles = [], x = 3, y = 2
    输出：true
    解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。

    示例 2：

    输入：command = "URR", obstacles = [[2, 2]], x = 3, y = 2
    输出：false
    解释：机器人在到达终点前会碰到(2, 2)的障碍物。

    示例 3：

    输入：command = "URR", obstacles = [[4, 2]], x = 3, y = 2
    输出：true
    解释：到达终点后，再碰到障碍物也不影响返回结果。
     
    限制：

    2 <= command的长度 <= 1000
    command由U，R构成，且至少有一个U，至少有一个R
    0 <= x <= 1e9, 0 <= y <= 1e9
    0 <= obstacles的长度 <= 1000
    obstacles[i]不为原点或者终点

 */

 /**
 * @param {string} command
 * @param {number[][]} obstacles
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
let command = "URR", obstacles = [[4, 2]], x = 3, y = 2
var robot = function(command, obstacles, x, y) {
  let list = command.split('')
  let xc = 0, yc = 0;
  let pathList = [[0,0]]  // 路线坐标
  let obj = {
    '[0,0]': -1
  }
  // 循环获取到第一次路线坐标 
  for(let i = 0; i<list.length;i++){
    if(list[i] === 'R'){
      xc++
    }else{
      yc++
    }
    pathList.push([xc,yc])
    obj[JSON.stringify([xc,yc])] = i
  }
  console.log(pathList)  // [[0,0],[0,1],[1,1],[2,1]]
  // 根据路线坐标判断能否能到达终点 
  // 先用终点x轴坐标值对第一次路线最后一个坐标x轴值取余,得到对应第一次路线的x坐标值,
  // y坐标
  let end = pathList.slice(-1)[0]
  let xl = +end[0]
  let yl = +end[1]
  let terminus = [x % xl, y - (parseInt(x / xl) * yl)] // 得到缩放后的终点 x y坐标
  if (!(JSON.stringify(terminus) in obj)) { //判断终点是否在运动轨迹上,js的数组没有高阶函数判断复杂类型的数组是否包含某一项,这里使用 对象的 in 操作符
    return false
  }
  return obstacles.every(item=>{
    let f = item[0]
    let s = item[1]
    if(f <= x && s <= y){
      let barrier = [f % xl, s - (parseInt(f/xl) * yl)] // 得到障碍物缩放后的 x y坐标
      if (JSON.stringify(barrier) in obj) { // 判断障碍物是否在运动轨迹上
        console.log('碰撞')
        return false
      }else{
        return true
      }
    }
    return true
  })
};
console.log(robot(command, obstacles, x, y))
</script>