<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  
</body>
</html>

<script>
/* 
  在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。

  给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

  返回可以通过分割得到的平衡字符串的最大数量。
  示例 1：

  输入：s = "RLRRLLRLRL"
  输出：4
  解释：s 可以分割为 "RL", "RRLL", "RL", "RL", 每个子字符串中都包含相同数量的 'L' 和 'R'。
  示例 2：

  输入：s = "RLLLLRRRLR"
  输出：3
  解释：s 可以分割为 "RL", "LLLRRR", "LR", 每个子字符串中都包含相同数量的 'L' 和 'R'。
  示例 3：

  输入：s = "LLLLRRRR"
  输出：1
  解释：s 只能保持原样 "LLLLRRRR".
   

  提示：

  1 <= s.length <= 1000
  s[i] = 'L' 或 'R'      

*/
/**
 * @param {string} s
 * @return {number}
 */
// 和約瑟夫環问题差不多 都可以用栈方法来解, 首先得把它转成数组,我们得遍历它,然后判断 每一项 等于 L 就加1 R就减1 等加和减都抵消了,就能截得一项了
 var balancedStringSplit = function(s) {
    let list = s.split('')
    let num = 0
    let stack = 0
    let len = list.length
    for(var i = 0;i<len;i++){
      if(list[i] === 'L'){
        stack++
      } else {
        stack--
      }
      if(stack === 0){
        num++ 
      }
    }
    return num
};
</script>