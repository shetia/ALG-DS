<!--
 * @Descripttion:
 * @version:
 * @Author: shetia
 * @Date: 2020-04-19 12:37:56
 * @LastEditors: somebody
 * @LastEditTime: 2020-04-19 18:24:25
 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>统计重复个数</title>
  </head>

  <body>
    <a
      href="https://leetcode-cn.com/problems/count-the-repetitions/"
      target="_branch"
      >统计重复个数</a
    >
    <pre>
  由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，["abc",3]=“abcabcabc”。

如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。

例如，根据定义，"abc" 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。

现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。

现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。

请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。
<code>
  示例：

  输入：
  s1 ="acb",n1 = 4
  s2 ="ab",n2 = 2

  返回：
  2
</code>
</pre>
  </body>
</html>
<script>
  /**
   * @param {string} s1
   * @param {number} n1
   * @param {string} s2
   * @param {number} n2
   * @return {number}
   */

  var getMaxRepetitions = function(s1, n1, s2, n2) {
    let S1 = Array(n1).fill(s1).join('')
    let S2 = Array(n2).fill(s2).join('')
    let nums = 0
    let index = 0
    for(let i = 0; i < S1.length; i++){
      if(S1[i] === S2[index]) index ++

      if(index === S2.length) {
        index = 0
        nums++
      }
    }
    return nums
  };
  let [s1, n1, s2, n2] = ["niconiconi",
99981,
"nico",
81];
  console.log(getMaxRepetitions(s1, n1, s2, n2));
</script>
